![image](https://github.com/user-attachments/assets/55d94649-1655-42c1-9de5-e4cf0cc17e00)# C#.NET

## OOPS

[1. Abstract Class vs Interface](#1.-abstract-class-vs-interface)

[2. Immutable vs Mutable / string vs StringBuilder](#2.-immutable-vs-mutable-/-string-vs-StringBuilder)


---------------------------------------------------------------------------------------
### 1. Abstract Class vs Interface
* Abstract class are half cooked classes having atleast 1 or more method bodies but Interface is a contract (Blueprint) having method declarations only and it cannot have any method definition.
* A class as a child can inherit only from one abstract class as a base but it can inherit multiple intefaces
* Access specifiers can be used in Abstract class but all method declarations are public in interface.
* Abstract classs can have ctor while interfaces does not.
  
_* Both Abstract class and interface cannot be instantiated (i.e cannot create objects)_

### 2. Immutable vs Mutable / string vs StringBuilder

Immutable = whose state CAN NOT Be changed e.g string class
Mutable = can be changed e.g. StringBuilder class

* When we modify the value of a string object, new memory is allowcated for new value and previous memory is released
* When multiple update operations are required on string then choose StringBuilder for better performance

### 3. Value vs Reference type

* A variable of a value type contains an instance of the type. This differs from a variable of a reference type, which contains a reference to an instance of the type.
* Value types are allocated on the stack only when used directly inside methods.

### 4. Stack vs Heap

  | |
  |-|
  | https://dev.to/tyrrrz/interview-question-heap-vs-stack-c-5aae |
  | ![image](https://github.com/user-attachments/assets/8870310d-1b9e-41ee-a87f-110c4bda53bf) |
  | ![image](https://github.com/user-attachments/assets/6b448969-c6a4-4d38-9e04-d5cf79b64932) |
  | ![image](https://github.com/user-attachments/assets/e021b2ee-93e3-4c12-96f7-c0e7b71e2379) |

### 5. Boxing/Unboxing

* Boxing = value type -> type object conversion
  e.g.  ```C#
      int i = 123;
      object o = i;     //BOXING 
      ```
  * Unboxing = object type -> value type 
    e.g.  int i = (int)o;  //UNBOXING

  * Both boxing and unboxing cause a performance hit
  * insights
    *  https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing
    *  ![image](https://github.com/user-attachments/assets/db772e65-0641-40c9-8225-7d227f0537b7)
   
### 6. Is string value type or ref?

string is ref type and its managed by GC

### 7. unmanaged types
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types
  - int - enum - tuple  => YES
  - structs  => NO
 
### 8. enums
  * enums are value types
  * enums are unmanaged types so its memory NOT managed by GC
  * underlying int type
  * support inheritance ?   NO

### 9. structs in C#

* structs are by default **value type.** So
  * passed by value while passed as arg to method or returning method results.
  * are MANAGED Code and its memory managed by GC
  * struct objects on which memory ?  STACK
* struct support inheritance ?   NO


### 10. Managed code

  






