# C#.NET

## OOPS

[1. Abstract Class vs Interface](#1.-abstract-class-vs-interface)

[2. Immutable vs Mutable / string vs StringBuilder](#2.-immutable-vs-mutable-/-string-vs-StringBuilder)

### 3. Value vs Reference type

### 4. Stack vs Heap

### 5. Boxing/Unboxing

### 6. Is string value type or ref?

### 7. unmanaged types
 
### 8. enums
  
### 9. structs in C#
  
### 10. Managed code

### 11. Nullable types / ? vs ?? vs Ternary operator (? :)

### 12. ref vs out keyword

### 13. const vs readonly

### 14. internal vs private access specifier

### 15. Function Overloading vs Function Overriding

### 16. tuple

### 17. Func vs Action vs Predicate 

### 18. abstract vs sealed vs static vs normal class

### 19. delegates & events

### 20. Garbage Collection, Dispose Pattern, GC.SuppressFinalize, using block, LOH (Large object heap)

### 21. Memory leaks / Have you worked with any scenarios with Memory issues
---------------------------------------------------------------------------------------
### 1. Abstract Class vs Interface
* Abstract class are half cooked classes having atleast 1 or more method bodies but Interface is a contract (Blueprint) having method declarations only and it cannot have any method definition.
* A class as a child can inherit only from one abstract class as a base but it can inherit multiple intefaces
* Access specifiers can be used in Abstract class but all method declarations are public in interface.
* Abstract classs can have ctor while interfaces does not.
  
_* Both Abstract class and interface cannot be instantiated (i.e cannot create objects)_

### 2. Immutable vs Mutable / string vs StringBuilder
Immutable = whose state CAN NOT Be changed after creation e.g value types, string class (exception)
Mutable = can be changed after creation e.g. StringBuilder class

* When we modify the value of a string object, new memory is allowcated for new value and previous memory is released
* When multiple update operations are required on string then choose StringBuilder for better performance

### 3. Value vs Reference type
* A variable of a value type contains an instance of the type. This differs from a variable of a reference type, which contains a reference to an instance of the type.
* Value types are allocated on the stack only when used directly inside methods.
* Value types are immutable

### 4. Stack vs Heap
  | |
  |-|
  | https://dev.to/tyrrrz/interview-question-heap-vs-stack-c-5aae |
  | ![image](https://github.com/user-attachments/assets/388445a9-985d-41c3-a105-16e86eb60947) |
  | ![image](https://github.com/user-attachments/assets/ec8c3004-0680-4303-acdc-24737d55560d) |
  | ![image](https://github.com/user-attachments/assets/e021b2ee-93e3-4c12-96f7-c0e7b71e2379) |

### 5. Boxing/Unboxing
  * Boxing = value type -> type object conversion
    ```.net
    int i = 123;
    object o = i;     //BOXING 
    ```
          
  * Unboxing = object type -> value type
    ```java
    int i = (int)o;  //UNBOXING
    ```
    
  * Both boxing and unboxing cause a performance hit
  * insights
    *  https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing
    *  ![image](https://github.com/user-attachments/assets/db772e65-0641-40c9-8225-7d227f0537b7)
   
### 6. Is string value type or ref?
* string is ref type and its managed by GC
* string is a reference type even though it has most of the characteristics of a value type such as being immutable

### 7. unmanaged types
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types
  - int - enum - tuple  => YES
  - structs  => NO
 
### 8. enums
  * enums are value types
  * enums are unmanaged types so its memory NOT managed by GC
  * underlying int type
  * support inheritance ?   NO

### 9. structs in C#
  * structs are by default **value type.** So
    * passed by value while passed as arg to method or returning method results.
    * are MANAGED Code and its memory managed by GC
    * struct objects on which memory ?  STACK
  * struct support inheritance ?   NO

### 10. Managed code
*  https://learn.microsoft.com/en-us/dotnet/standard/managed-code

*  **MANAGED CODE **
    *  Code whose execution is managed by Common Language Runtime or CLR
    *  The CLR is in charge of taking the managed code, compiling it into machine code and then executing it.
    *  The CLR provides several important services such as automatic memory management, security boundaries, and type safety.
      
    *  Examples of unmanaged code - File Handles, Network connection objects
       C/C++ programs = "unmanaged code" binary that the operating system (OS) loads into memory and starts.
    *  C# code = Managed code => Compling it returns  Intermediate Language code => CLR converts it into Machine code/binary executables.       

### 11. Nullable types / ? vs ?? vs Ternary operator (? :)
|                      |                                                                                                             |
| -------------------- | ----------------------------------------------------------------------------------------------------------- |
| Ternary operator     |  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator          |
|                      |  is this condition true ? yes : no                                                                        
| Nullable Types       |  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types      |
|    T?                |  Used for **VALUE Types**                                                                                   |
|                      |  A nullable value type T? represents all values of its underlying value type T and an additional null value.|
|                      |  e.g. bool? b;  // b can be assigned any values from true, false, or null. DEFAULT value being null         |
|                      |  **is** operator can be used with T? nullable types as shown below:-                                        | 
|                      |  ![image](https://github.com/user-attachments/assets/488920df-2e83-4d68-bb9c-31849e1cd824)                  |
|                      |  **HasValue**  property can be used to test whether the variable contains a value before displaying it.     |
|                      |  ![image](https://github.com/user-attachments/assets/f7fb9159-62b1-4327-bd0a-a85d0d4bd3ff)                  |
| Null-coalescing Op's |  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator      |
|    ?? and ??=        |  Used to define a default value for nullable value types.                                                   |
|                      |  ??   Returns the value of its left-hand operand if it isn't null; **otherwise**,                           |
|                      |       it evaluates the right-hand operand and returns its result.                                           |
|                      |  ??=  Assigns the value of its right-hand operand to its left-hand operand **only if**                      |
|                      |       the left-hand operand evaluates to null.                                                              |
|                      |       ??= operator doesn't evaluate its right-hand operand if the left-hand operand evaluates to non-null.  |
|                      | ![image](https://github.com/user-attachments/assets/c4bb1d43-d3bb-48b8-a1fe-c134e2b10754)                   |

### 12. ref vs out keyword
 | |
 |-|
 | ![image](https://github.com/user-attachments/assets/51253aa8-1d43-4c5b-81b0-df05e8acb4dd) |
 | https://www.c-sharpcorner.com/UploadFile/ff2f08/ref-vs-out-keywords-in-C-Sharp/           |
 | https://www.tutorialspoint.com/difference-between-out-and-ref-keyword-in-chash            |

 | ![image](https://github.com/user-attachments/assets/5dff1e49-76fb-4b8f-a9bc-8d1d7857d193) |

### 13. const vs readonly
*  ![image](https://github.com/user-attachments/assets/ec311d17-c011-4cf8-829d-17d8da9bae36)
*  https://dotnettutorials.net/lesson/const-and-read-only-csharp/
   
### 14. internal vs private access specifier
![image](https://github.com/user-attachments/assets/56357ffc-3ea0-4a4d-afac-befdfd0e8c9e)
![image](https://github.com/user-attachments/assets/d76009c3-9883-49b3-be8b-70ff90475245)

### 15. Function Overloading vs Function Overriding
https://www.shiksha.com/online-courses/articles/difference-between-overloading-and-overriding/
![image](https://github.com/user-attachments/assets/3bfcc9c3-3141-40d7-a00c-2a5837dcc62f)

### 16. tuple
 • Used to return multiple data values.    From <https://www.c-sharpcorner.com/article/tuples-in-c-sharp/>  
 • provides concise syntax to group multiple data elements in a lightweight data structure. 
   
   https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples

   ![image](https://github.com/user-attachments/assets/a01042fb-9f1b-44ea-98ae-05b5606125c3)  

### 17. Func vs Action vs Predicate 
 * https://www.tutorialsteacher.com/csharp/csharp-func-delegate
 * https://learn.microsoft.com/en-us/dotnet/api/system.func-2?view=net-9.0
   ![image](https://github.com/user-attachments/assets/db90607e-0df8-4594-a3e9-326418d1db22)

### 18. abstract vs sealed vs static vs normal class
  * ![image](https://github.com/user-attachments/assets/04192a38-f4cb-427c-9c74-af5038eb17d8)
  * ![image](https://github.com/user-attachments/assets/2169f9f1-2cb2-43a9-81aa-39bec1519701)

### 19. delegates & events 
|           |                                                                                                                          |
| ----------| ------------------------------------------------------------------------------------------------------------------------ |
|           | https://chatgpt.com/c/67d8ab6e-5998-8007-af3f-52f038bdfbfe                                                               |
| Delegates | A delegate is a type that represents a reference to a method. It allows methods to be passed as paramete,                |
|           | making it useful for designing flexible and reusable code.                                                               |
|           |  ![image](https://github.com/user-attachments/assets/74309a0f-7f23-468e-99de-390d6a151b3d)                               |
|           |  ![image](https://github.com/user-attachments/assets/22732c19-6f47-47e9-bece-e02034bc87c0)                               |
| Events    | An event is a special type of delegate that ensures encapsulation, preventing external classes from invoking it directly.|
|           | ![image](https://github.com/user-attachments/assets/11ced694-74f6-41b8-aeb5-8ab451f4739b)                                |
|           | ![image](https://github.com/user-attachments/assets/0ebfe9d8-d30d-4542-ba3c-762808f8c0a3)                                |
|           |  ![image](https://github.com/user-attachments/assets/9fd7ab6e-ca61-4534-b913-ad4168f3ce78)                               |
|           |  Another example - https://medium.com/@ravipatel.it/understanding-events-in-c-with-practical-examples-8cb5ad547a35       |    
|           |                                                                                                                          |
       
### 20. Garbage Collection, Dispose Pattern, GC.SuppressFinalize, using block, LOH (Large object heap)
 https://www.csharp.com/article/garbage-collection-dispose-vs-finalize-and-idisposable-pattern/
  | Garbage collector - how it works |
  
  Idisposable
        -  can we call destructor/finallizer
        -  Can we call dispose 
        -  suppress finaller keyword ?
        
    • Dispose vs finalizer
    • using block
    IDisposable
    why finaliser /dispose
    Using block 
    • GC . GC.SuppressFinalize
    • GC.KeepAlive property
    • Can objects be moved from Gen0 to Gen2 directly if this is large size object
-----------------------------------------------
  ## Garbage Collection - Dispose Vs Finalize And IDisposable Pattern
  Introduction

In this article, we are going to see how to Finalize, Destructor, IDisposable pattern, and Use block work in a C# application.

Let's have a small introduction to all of them.

Finalize - This is used to release unmanaged resources.

The managed resources are like classes created in C#, Vb.Net, and any other class created under .net languages.

The cleanup and releasing of the unmanaged resources are done under the finalize method.

If your class is not using unmanaged resources then forget about the Finalize method. If your class is using unmanaged resources then implement finalize method.

We can not call the finalize method using the class object. The finalized method is called by garbage collector.

Finalize queue

The first time when the object is created then it is going to sit in generation 0. The Garbage collector frequently checks generation 0 whether any object is inactive. If the object is inactive and no one is using the object then immediately it is going to release and deallocate the memory.

In the same way, the garbage collector checks the object header and finds the object has implemented the finalize method then the garbage collector moves that object to the finalize queue.

The checking of the finalized queue is much less. Even if the object is inactive and the object is not more in usage still it will be in the memory heap and also we don’t know when it will release the unmanaged resources.

When the code is compiled then the destructor is converted to finalize. Whenever we use unmanaged resources then make sure to implement the destructor method.

Create a sample console project.

Add classes as below

namespace GarbageCollectorProgram
{
    class ClassA
    {
        public ClassA()
        {
            Console.WriteLine("Created ClassA");
        }
        ~ClassA()
        {
            Console.WriteLine("Destructing -- ClassA");
        }
    }
    class ClassB : ClassA
    {
        public ClassB()
        {
            Console.WriteLine("Creating ClassB");
        }
        ~ClassB()
        {
            Console.WriteLine("Destructing -- ClassB");
        }
    }
    class ClassC : ClassB
    {
        public ClassC()
        {
            Console.WriteLine("Creating ClassC");
        }
        ~ClassC()
        {
            Console.WriteLine("Destructing -- ClassC");
        }
    }
    class ClassD
    {
    }
}

C#

Open program.cs

namespace GarbageCollectorProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            ClassC objC = new ClassC();
            Console.WriteLine("Object C is created..");
            objC = null;
            Console.WriteLine("Object C is assigned to null.. Object now destructing..");
            Console.ReadLine();
        }
    }
}

C#

Class

You can see the finalized method, but where is the destructor method? This is getting converted to override the finalize method. So, using the destructor we define the finalize method.

Let us see how the destructor is calling.

Run the application

Created class

You can see the garbage collector didn’t call the finalize method of these classes.

Then when we close the exe at that time it will call the finalize method of all the classes. Even if the object is inactive it is still a Garbage collector who maintains the object’s memory.

Final method of all classes

GC.Collect();

C#

Let’s see what GC.Collect() does.

The garbage collector’s Collect() method instructs the GC to clear off or deallocate all the inactive object’s memory. This is a very expensive operation and goes to all the generations (0,1,2) to clear off the memory or deallocate the objects in one shot.

In our program objC = null; we are doing nothing but making the object objC inactive and the statement GC.Collect() goes on and immediately releases the objects.

Change the main method’s statements as below.

ClassC objC = new ClassC();
            Console.WriteLine("Object C is created..");
            objC = null;
            GC.Collect();
            Console.WriteLine("Object C is assigned to null.. Object now destructing..");
            Console.ReadLine();

C#

Now run the application

Run the application

There is a performance issue when keeping the inactive objects memory for a long time and this is not the right technique to manage the memory,
IDisposable Interface

IDisposable has only one method which is the Dispose method. We can use the disposal method for the same purpose to clean up the unmanaged resources. So when you are done with your object then simply call the dispose method.

Let us take an example that will implement the Dispose method of the IDisposable interface.

Add the class below

namespace GarbageCollectorPorgram
{
    public class DisposableTest : IDisposable
    {
        private bool isDisposed = false;

        public void Print(string message)
        {
            Console.WriteLine("Hello " + message);
        }
        ~DisposableTest()
        {
            Console.WriteLine("Destructor/Finalize of DisposableTest");
            Dispose(false);
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        protected void Dispose(bool dispose)
        {
            if (!isDisposed)
            {
                if (dispose)
                {
                    // to cleanup managed objects
                }
                // To cleanup unmanaged resources/objects
                isDisposed = true;
            }
        }
    }
}

C#

Click on IDisposable and press f12

Namespace

You can see there is only one method Dispose.

If we are implementing the Dispose method then it means we have got the control of whenever you want to call the dispose method based on the right time according to you. So whoever is using the class has the responsibility to clear the unmanaged resources.

If you are depending on the disposal method then there is a possibility that we forgot to call the disposal method which will happen Also, it may cause a memory leak.

So we have implemented the finalize as well as the Dispose method. Now, if the user forgets to call the disposal method then that time my finalized method will activate. Also if the user calls the dispose method then I don’t want to call the finalize method to activate. So we have specified in Dispose method().

public void Dispose()
{
    Dispose(true);
    GC.SuppressFinalize(this);
}

C#

Suppose the user called the dispose method then internally we are specifying the GC to suppress the finalize for the particular 'this' object. That means it will be taken out from the finalize queue immediately, and the Finalize method will not be triggered by the Garbage collector.

Also, we can use IDisposable for releasing the managed, unmanaged resources and components.

In our program, we have finalized the method to release unmanaged resources.

~DisposableTest()
{
    Console.WriteLine("Destructor/Finalize of DisposableTest");
    Dispose(false);
}

C#

We are passing false inside the Dispose method.

protected void Dispose(bool dispose)
{
    if (!isDisposed) // will be true
    {
        if (dispose)
        {
            // to cleanup managed objects
        }
        // To cleanup unmanaged resources/objects
        isDisposed = true;
    }
}

C#

So, the first step will be true and it will check another if(dispose) that will be false, and this will only clean up the unmanaged resources and set the value idDisposed to true.

Open program.cs

namespace GarbageCollectorPorgram
{
    class Program
    {
        static void Main(string[] args)
        {
            DisposableTest obj = new DisposableTest();
            Console.WriteLine("DisposableTest object is created..");
            obj.Print("Good Morning..");
            obj = null;
            Console.WriteLine("Assigned null..  Object is destructing..");
            Console.ReadLine();
        }
    }
}

C#

Run the application

Dispose

The finalize method has not been called.
Press any key

Destructor

Then the finalize method is called.

So when we close the exe the garbage collector calls the finalize method. Even if you have implemented the IDisposable dispose method but forgot to call the dispose method then it will call the finalize method.

Now let us call the disposal method

Change the program.cs statements

namespace GarbageCollectorPorgram
{
    class Program
    {
        static void Main(string[] args)
        {
            DisposableTest obj = new DisposableTest();
            Console.WriteLine("DisposableTest object is created..");
            obj.Print("Good Morning..");
            obj.Dispose();
            obj = null;
            Console.WriteLine("Assigned null..  Object is destructing..");
            Console.ReadLine();
        }
    }
}

C#

Run the application

Assigned null

Now you will not see the Destructor/finalize of the object statement execution. It means the Dispose is going to take care of releasing the unmanaged resources and also suppress the finalize method.
Using block

Open program. cs and change the statements as below.

namespace GarbageCollectorPorgram
{
    class Program
    {
        static void Main(string[] args)
        {
            using (DisposableTest obj = new DisposableTest())
            {
                Console.WriteLine("DisposableTest object is created..");
                obj.Print("Good Morning..");
            }
            Console.WriteLine("Assigned null..  Object is destructing..");
            Console.ReadLine();
        }
    }
}

C#

To avoid the calling of dispose method and to forget the calling of dispose method. Dot Net has introduced a Usign block.

So if you are creating the object that has implemented the IDisposable interface then Using block will take care of calling the dispose method for the object. At the end of the block, it will automatically call the Dispose method.

Run the application

Object destruct

You can see the object didn’t call the finalize method.

So if any class has implemented the IDisposable interface then try using the Using block to create the instance.

So many classes like the db connection class have implemented the Dispose method. So, if you are seeing the Dispose method has been implemented then try using the Using block to create the object.

EG. If you are creating the SqlConnection object/instance then try creating under Using block because SqlConnection implements the Dispose method that dispose method is used to release the DB Connection, and db Connection are unmanaged resources.

So the best practice is that if you are using the class/.net classes that have implemented the Dispose method then try to create an object under Using block. If you are not using the Using block then make sure to call the dispose method explicitly. This practice will help to avoid the GC finalize queue, and also to improve the performance.
-----------------------------------------------------------------------------------------------------
    
 | | |
 |-|-|
 | Finalize     | ![image](https://github.com/user-attachments/assets/ea86ab07-f452-420a-9593-476b67baebc6) |
 |              | ![image](https://github.com/user-attachments/assets/146fb32b-3001-4d03-af97-d1be11653a46) |
 |              | ![image](https://github.com/user-attachments/assets/47d954a7-7297-4ec5-b7f4-4c15d4fc8d08) |
 |              | ![image](https://github.com/user-attachments/assets/b65e4f10-4a48-4161-b0ba-90f2cf46f687) |
 | GC.Collect() | ![image](https://github.com/user-attachments/assets/809e986c-a262-4632-914d-2499e8b1e350)  |
 | IDisposable  | ![image](https://github.com/user-attachments/assets/2adaecde-a7b3-4ec7-a2cc-b8dfbf448a51)  |
 |              | ![image](https://github.com/user-attachments/assets/a9694814-82e3-4cb0-82cf-b2a40f0ab8bd)  |
 |              | ![image](https://github.com/user-attachments/assets/46fa8a7f-1f16-44c1-97f0-9220f509c8f7)  |
 |              | ![image](https://github.com/user-attachments/assets/e10fb356-60b7-4aa7-9513-ed3ba1f14c82)  |
 |              | ![image](https://github.com/user-attachments/assets/08efde31-ecef-431d-be22-addadad37820)  |
 | using block  |  ![image](https://github.com/user-attachments/assets/a5b8205d-9767-43b1-8181-f671bb9b161b) |
 |              |  ![image](https://github.com/user-attachments/assets/3b1d8777-9278-4325-a406-a977f1570144) |
 |              |  |


### 21. Memory leaks / Have you worked with any scenarios with Memory issues
* Yes, Keysight applications which UI extensive and logging data from instruments for many days or even month and displaying data for a vast range based on filter like AUTO SCALE or specific time range.
* Used memory profiler to diagnose the memory usage over time and performance

*  Refer this article for various other scenarios
  https://dev.to/arunkumar2331996/memory-leaks-in-c-3koj

### 22. 




  






